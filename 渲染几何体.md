# 利用 Direct3D 绘制几何体

## 输入与顶点布局

```cc
struct Vertex1 {
    XMFLOAT3	position;
    XMFLOAT3	color;
};

struct Vertex2 {
    XMFLOAT3	position;
    XMFLOAT3	normal;
    XMFLOAT2	tex0;
    XMFLOAT2	tex1;
};
```

定义顶点结构体之后, 我们需要向 Direct3D 提供改顶点结构体的描述**输入布局描述** 
用结构体 `D3D12_INPUT_LAYOUT_DESC` 来表示

```cc
typedef struct D3D12_INPUT_LAYOUT_DESC {
    LPCSTR						SemanticName;	
    UINT						SemanticIndex;		
    DXGI_FORMAT					Format;				
    UINT						InputSlot;			
    UINT						AlignedByteOffset;	
    D3D12_INPUT_CLASSIFICATION 	InputSlotClass;		
    UINT						InstanceDataStepRate;
} D3D12_INPUT_LAYOUT_DESC;

typedef struct D3D12_INPUT_LAYOUT_DESC {
    const D3D12_INPUT_ELEMENT_DESC *pInputElemetsDescs;
    UINT  NumElements;
} D3D12_INPUT_LAYOUT_DESC;
```

* `SemanticName` 语义名
* `SemanticIndex` 语义索引
* `Format` 格式
* `InputSlot` 指定元素所用的输入槽. D3D支持16个输入槽(0~15). 目前我们只会使用到输入槽 0
* `AlignedByteOffset` 在顶点结构体中, 字段所代表的偏移
* `InputSlotClass` 暂定此参数为
  `D3D12_INPUT_CLASSIFICCATION_PER_VERTEX_DATA`. 如果要使用实例化.
  指定 `D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA`
* `InstanceDataStepRate` 设置为 0, 使用实例化时设置为 1

**简单示例**

```cc
struct Vertex {
    XMFLOAT	position;
    XMFLOAT	normal;
    XMFLOAT	tex0;
    XMFLOAT	tex1;
};

constexpr int isInstance = 0;
constexpr auto slotClass = D3D12_INPUT_CLASSIFICCATION_PER_VERTEX_DATA;
D3D12_INPUT_ELEMENT_DESC vertexDesc[] = {
    {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, offsetof(Vertex, position), slotClass, 0 },
    { "NORMAL",  0, DXGI_FORMAT_R32G32B32_FLOAT, 0, offsetof(Vertex, normal),   slotClass, 0 },
    { "TEXCOORD",0, DXGI_FORMAT_R32G32_FLOAT,    0, offsetof(Vertex, tex0),		slotClass, 0 },
    { "TEXCOORD",1, DXGI_FORMAT_R32G32_FLOAT,	 0, offsetof(Vertex, tex1), 	slotClass, 0 },
};

//----------------------------上面C++顶点结构和布局描述;下面hlsl顶点着色器--------------------------------
VertexOut vs(
    float3 position : POSITION,			// 对于布局中的 POSITION
	float3 normal   : NORMAL,  			// 对于布局中的 NORMAL
    float2 tex0		: TEXTURE0,			// 对于布局中的 TEXCOORD 0
    float2 tex1 	: TEXTURE1			// 对于布局中的 TEXC
) {
    ...
}
```

## 顶点缓冲区

为了使 GPU 可以访问顶点数组, 需要把它们放置在缓冲区中(`ID3D12Resource`).
缓冲区的结构比纹理更简单: 非多维资源; 不支持mipmap; 不支持过滤; 不支持多重采样
先填写 `D3D12_RESOURCE_DESC` 描述缓冲区, 接着调用 `ID3D12Device::CreateCommitedResource`

`Direct3D 12` 提供一个 `C++` 包装类. 简化 `D3D12_RESOURCE_DESC` 的构造函数

```cc
static inline CD3DX12_RESOURCE_DESC Buffer(
	UINT64	width,
    D3D12_RESOURCE_FLOAGS flags = D3D12_RESOURCE_FLAG_NONE,
    UINT64 alignment = 0
) {
    return CD3DX12_RESOURCE_DESC(
    	alignment, width, 1, 1, 1,
        DIGI_FORMAT_UNKNOW, 1, 0,
        D3D12_TEXTURE_LAYOUT_ROW_MAJOR, flags
    );
}
```

Note:

> 除此之外. `CD3DX12_RESOURCE_DESC` 还提供了下列方法. 简单的使用 `D3D12_RESOURCE_DESC`
>
> 1. `CD3DX12_RESOURCE_DESC::Tex1D`
> 2. `CD3DX12_RESOURCE_DESC::Tex2D`
> 3. `CD3DX12_RESOURCE_DESC::Tex3D`

Note:

> 深度/模板缓冲区是以 `ID3D12Resource` 表示的 2D 纹理. 在 `Direct12` 中, 缓冲区和纹理都是使用 `ID3D12Resource` 描述. 使用 `D3D12_RESOURCE_DESC::D3D12_RESOURCE_DIMENSION` 字段来区分

## 默认堆

对于静态几何体, 我们会将顶点数据放置在默认堆中(`D3D12_HEAP_TYPE_DEFAULT`)来优化性能. **但是 CPU 不能向默认堆中的顶点缓冲区写入数据**, 我们需要使用 `D3D12_HEAP_TYPE_UPLOAD` 创建一个上传堆, 把数据经过上传堆 copy 到默认堆

定义一个工具函数:

```CC
// when the call is complete, uploadbuffer cannot understand destory
// You must wait for the data copy to complete
ComPtr<ID3D12Resource> CreateDefaultBuffer(
	ID3D12Device *device,
	ID3D12GraphicsCommandList *cmdList,
	const void *initData,
	UINT64 byteSize,
    ComPtr<ID3D12Resource> &uploadBuffer
) {
	SAssert(device != nullptr, "createDefaultBuffer device is nullptr");
	SAssert(cmdList != nullptr, "createDefaultBuffer cmdList is nullptr");

	// create default heap
	WRL::ComPtr<ID3D12Resource> defaultBuffer;
	ThrowIfFailed(device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(byteSize),
		D3D12_RESOURCE_STATE_COMMON,
		nullptr,
		IID_PPV_ARGS(&defaultBuffer)
	));

	// create upload heap
	ThrowIfFailed(device->CreateCommittedResource(
		&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
		D3D12_HEAP_FLAG_NONE,
		&CD3DX12_RESOURCE_DESC::Buffer(byteSize),
		D3D12_RESOURCE_STATE_COMMON,
		nullptr,
		IID_PPV_ARGS(&uploadBuffer)
	));

	// describes the data we want to copy to the default buffer
	D3D12_SUBRESOURCE_DATA subResourceData = {};
	subResourceData.pData = initData;
	subResourceData.RowPitch = byteSize;
	subResourceData.SlicePitch = subResourceData.RowPitch;

	// copy the data to upload heap using the UpdateResources function
	cmdList->ResourceBarrier(1,
		&CD3DX12_RESOURCE_BARRIER::Transition(
			defaultBuffer.Get(),
			D3D12_RESOURCE_STATE_COMMON,
			D3D12_RESOURCE_STATE_COPY_DEST
	));
	UpdateSubresources(cmdList, defaultBuffer.Get(), uploadBuffer.Get(), 
                       0, 0, 1, &subResourceData);
	cmdList->ResourceBarrier(1,
		&CD3DX12_RESOURCE_BARRIER::Transition(
			defaultBuffer.Get(),
			D3D12_RESOURCE_STATE_COMMON,
			D3D12_RESOURCE_STATE_GENERIC_READ
	));
	return defaultBuffer;
}
```

`D3D12_SUBRESOURCE_DATA` 的结构体的定义为

```cc
typedef struct D3D12_SUBRESOURCE_DATA {
    const void *pData;			// 数据地址
    LONG_PTR 	RowPitch;		// 对于缓冲区来说. 复制字节数
    LONG_PTR 	SlicePitch;		// 对于缓冲区来说, 复制字节数
} D3D12_SUBRESOURCE_DATA;
```

**创建立方体的八个顶点例子**

```cc
Vertex vertices[] = {
    { XMFLOAT3(-1.f, -1.f, -1.f), XMFLOAT4(Colors::White) 	},
    { XMFLOAT3(-1.f, +1.f, -1.f), XMFLOAT4(Colors::Black) 	},
    { XMFLOAT3(+1.f, +1.f, -1.f), XMFLOAT4(Colors::Red) 	},
    { XMFLOAT3(+1.f, -1.f, -1.f), XMFLOAT4(Colors::Green) 	},
    { XMFLOAT3(-1.f, -1.f, +1.f), XMFLOAT4(Colors::Blue) 	},
    { XMFLOAT3(-1.f, +1.f, +1.f), XMFLOAT4(Colors::Yellow) 	},
    { XMFLOAT3(+1.f, +1.f, +1.f), XMFLOAT4(Colors::Cyan) 	},
    { XMFLOAT3(+1.f, -1.f, +1.f), XMFLOAT4(Colors::Magenta) },
};

ComPtr<ID3D12Resource> vertexBufferGPU = nullptr;
ComPtr<ID3d12Resource> VertexBufferUpload = nullptr;
vertexBufferGPU = CreateDefaultBuffer(
    d3dDevice_.Get(),
    commandList_.Get(),
    vertices,
    sizeof(vertices),
    VertexBufferUpload
);
```

为了将顶点缓冲区绑定到流水线上, 我们需要给这种资源创建一个视图. 与 RTV 不同的是, 我们无须为顶点缓冲区视图创建描述符堆. 
顶点缓冲区视图由 `D3D12_VERTEX_BUFFER_VIEW` 描述

```cc
typedef struct D3D12_VERTEX_BUFFER_VIEW {
    D3D12_GPU_VIRTUAL_ADDRESS 	BufferLocation;
    UINT						SizeInBytes;
    UINT						StrideInBytes;
} D3D12_VERTEX_BUFFER_VIEW;
```

| 字段             | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| `BufferLocation` | 待创建的视图的顶点缓冲区虚拟资源地址. 我们可以通过`ID3D12Resource::GetGPUVirtualAddress` 方法获得 |
| `SizeInBytes`    | 待创建的视图的顶点缓冲区大小                                 |
| `StrideInBytes`  | 每个顶点元素所占用的字节数                                   |

在顶点缓冲区对应视图创建完成以后. 可以和渲染流水线上面的 `InputSlot` 绑定.

```cc
void ID3D12GraphicsCommandList::IASetVertexBuffers(
	UINT	StartSlot,	// 绑定多个缓冲区时的起始槽(一共有16个, 0~15)
    UINT	NumView,	// pViews 里面的元素数量
    const D3D12_VERTEXX_BUFFER_VIEW *pViews // view 指针
);
```

```cc
ID3D12Resource *vb1_;
ID3D12Resource *vb2_;
D3D12_VERTEX_BUFFER_VIEW vbView1;
D3D12_VERTEX_BUFFER_VIEW vbView2;

// create vertex buffer and view

commandList_->IsSetVertexBuffers(0, 1, &vbView1);
// use vertex buffer1 draw
commandList_->IsSetVertexBuffers(0, 1, &vbView2);
// use vertex buffer2 draw
```

单顶点缓冲区设置到输入槽后不会进行实际的绘制操作, 这是为顶点数据传递到渲染流水线做准备. 需要调用 `ID3D12GraphicsCommandList::DrawInstanced` 方法才是绘制

```cc
		// 顶点缓冲器内存
-----------------------------------------
|	|	|	|	|	|	| 	|	|	|	|
-----------------------------------------
    	|					|
    	|--- VertexCount ---|
// 	 start

void ID3D12GraphicsCommandList::DrawInstanced(
	UINT VertexCountPerInstance,	// 绘制的顶点数量
    UINT InstanceCount,				// 绘制的实例数.目前设置为1
    UINT StarVertexLocation,		// 指定顶点缓冲区内第一个被绘制的顶点索引
    UINT StarInstanceLocation		// 实例化使用,目前设置为0
);
```

`DrawInstanced` 函数没有指定绘制的图元类型, 还需要使用 `IASetPrimitiveTopology`

```cc
cmdList_->IASetPrimitiveTopology(D3D12_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
```

## 索引和索引缓冲区

我们需要给索引缓冲区创建一个索引视图

```cc
typedef struct D3D12_INDEX_BUFFER_VIEW {
  	D3D12_GPU_VIRTUAL_ADDRESS 	BufferLocation;
    UINT						SizeInByte;
    DXGI_FORMAT					Format;
} D3D12_INDEX_BUFFER_VIEW;
```

| 字段             | 描述                                               |
| ---------------- | -------------------------------------------------- |
| `BufferLocation` | 待创建视图的索引缓冲区的资源虚拟地址               |
| `SizeInByte`     | 索引缓冲区的大小(字节表示)                         |
| `Format`         | `DXGI_FORMAT_R16_UINT` 或者 `DXGI_FORMAT_R32_UINT` |

与顶点缓冲区相似, 在使用之前我们需要绑定到流水线上. 
通过调用 `ID3D12GraphicsCommandList::IASetIndexBuffer` 方法

```cc
uint16_t indices[] = {
    0, 1, 2, 0, 2, 3,		// 前
    4, 6, 5, 4, 7, 6,		// 后
    4, 5, 1, 4, 1, 0,		// 左
    3, 2, 6, 3, 6, 7,		// 右
    1, 5, 6, 1, 6, 2,		// 上
    4, 0, 3, 4, 3, 7,		// 下
};

ComPtr<ID3D12Resource> indexBufferGPU;
ComPtr<ID3d12Resource> indexBufferUploader;
indexBufferGPU = CreateDefaultBuffer(
	d3dDevice_.Get(),
    commandList_.Get(),
    indices, 
    sizeof(indices),
    indexBufferUploader
);

// bind buffer to pipelined
D3D12_INDEX_BUFFER_VIEW ibv;
ibv.BufferLocation = indexBufferGPU->GetGPUVirtualAddress();
ibv.Format = DXGI_FORMAT_R16_UINT;
ibv.SizeInByte = sizeof(indices);
commandList_->IASetIndexBuffer(&ibv);
```

在使用索引时, 我们需要使用 `ID3D12GraphicsCommandList::DrawIndexedInstanced` 绘制

```cc
/* 
 * @brief:							绘制
 * @param IndexCoutPerInstance:		每个实例要绘制的索引数
 * @param InstanceCount:			用于实例化使用, 我们目前使用1
 * @param StartIndexLocation:		索引缓冲区的起始索引
 * @param BaseVertexLocation:		在本次绘制调用读取顶点之前, 要为每个索引加上这个数
 * @param StartInstanceLocation:	实例化使用目前传递为0
 */
void ID3D12GraphicsCommandList::DrawIndexedInstanced(
	UINT IndexCoutPerInstance,
    UINT InstanceCount,
    UINT StartIndexLocation,
    INT  BaseVertexLocation,
    UINT StartInstanceLocation
);
```

## 合并顶点与索引

假设我们有 3 个物体: 分别是 球体, 立方体, 圆柱体. 用于这3个物体的顶点, 索引. 现在我们把所有的顶点和索引依次放置在一起. 因为原来的索引是局部下标, 所以合并后的索引不正确了

![image-20211012214010714](image-20211012214010714.png)

```cc
uint vertexOffset = 0;
uint indexOffset = 0;

// draw sphere
commandList_->DrawIndexedInstanced(
	numSphereIndices, 1, indexOffset, vertexOffset, 0
);
vertexOffset += numSphereVertexSize;		// move to cube vertex
indexOffset  += numSphereIndices;			// move to cube indices

// draw box
commandList_->DrawIndexedInstanced(
	numBoxIndices, 1, indexOffset, vertexOffset, 0
);
vertexOffset += numBoxVertexSize;
indexOffset  += numBoxIndices;

// draw Cyl
commandList_->DrawIndexedInstanced(
	numCylIndices, 1, indexOffset, vertexOffset, 0
);
vertexOffset += numCylVertexSize;
indexOffset  += numCylIndices;
```

## 顶点着色器

```hlsl
cbuffer cbPerObject : register(b0) {
	float4x4 gWorldViewProj;
};

void VS(in  float iPosL 	: POSITION,
		in  float4 iColor 	: COLOR,
		out float4 oPosH 	: SV_POSITION
		out float4 oColor	: COLOR) 
{
	oPosH  = mul(float4(iPosL, 1.0f), gWorldViewProj);
    oColor = iColor;
}
```

使用结构体作为输入输出

```hlsl
cbuffer cbPerObject : register(b0) {
    float4x4 gWorldViewProj;
};
struct VertexIn {
	float3 PosL  : POSITION;
    float4 Color : Color;
};
struct VertexOut {
	float4 PosH 	: SV_POSITION;
	float4 Color 	: COLOR;
};
VertexOut VS(VertexIn vin) {
	VertexOut vout;
	vout.PosH  = mul(float4(iPosL, 1.0f), gWorldViewProj);
	vout.Color = vin.Color;
	return vout;
}
```

## 像素着色器

版本1

```hlsl
float4 PS(float4 posH  :  SV_POSITION
		  float4 color : COLOR) : SV_Target 
{
	return color;		  
}
```

版本2

```cc
float4 PS(VertexOut pin) : SV_Target {
    return pin.Color;
}
```

## 常量缓冲区

类似于 `OpenGL` 的 `uniform` 变量

```hlsl
// 语法1
cbuffer cbPerObject : register(b0) {
	float4x4 gWorldViewProj;
};

// hlsl 引入的语法
struct ObjectConstants {
	float4x4	gWorldViewProj
	uint 		matIndex;
};

ConstantBuffer<ObjectConstants> gObjConstants : register(b0);
```

常量缓冲区有对齐要求. 必须对齐 256 

**示例**

```cc
struct ObjectConstants {
    DirectX::XMFLOAT4X4  worldViewProj = MathHelper::Identity4x4();
};

// 256 byte alignment
size_t emelentByteSize = CalcConstantBufferByteSize(sizeof(ObjectConstants));
ComPtr<ID3D12Resource> uploadCBuffer;
d3dDevice_->CreateCommitedResource(
	&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
    D3D12_HEAP_FLAG_NONE,
    &CD3DX12_RESOURCE_DESC::Buffer(emelentByteSize * NumElements),
    D3D12_RESOURCE_STATE_GENERIC_READ,
    nullptr,
    IID_PPV_ARGS(&uploadCBuffer)
);
```

## 更新常量缓冲区

常量缓冲区是用 `D3D12_HEAP_TYPE_UPLOAD` 类型创建, 所以我们能够通过 CPU 为常量缓冲区更新资源

可以使用 `Map` 函数获取资源的内存

```cc
ComPtr<ID3D12Resource> uploadBuffer;
BYTE *pMappedData = nullptr;
uploadBuffer->Map(0, nullptr, reinterpret_cast<void **>(&pMappedData));
memcpy(pMappedData, data, sizeof(data));		// copy data to buffer
uploadBuffer->Unmap(0, nullptr);
uploadBuffer = nullptr;
```

### 上传缓冲区辅助函数

```cc
template<typename T>
class UploadBuffer {
    UploadBuffer(ID3D12Device *device, UINT elementCout, bool isConstanBuffer);
	UploadBuffer(const UploadBuffer &) = delete;
    UploadBuffer &operator(const UploadBuffer &) = delete;
    ID3D12Resource *resource() const;
    void copyData(int elementIndex, const T &data);
    ~UploadBuffer();
private:
    ComPtr<ID3D12Resource> uploadBuffer_ = nullptr;
    BYTE 				  *mappedData_ = nullptr;
    UINT 				   elementByteSize_ = 0;
    bool 				   isContanstBuffer_ = false;
};

UploadBuffer::UploadBuffer(ID3D12Device *device, 
                           UINT elementCout, 
                           bool isConstanBuffer)
: isConstanBuffer_(isConstanBuffer)
{
    elementByteSize_ = sizeof(T);
    if (isConstantBuffer) {
        // adjust elementByteSize_ base 256
    }
    ThrowIfFailed(device->CreateCommitedResource(
    	&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
        D3D12_HEAP_FLAG_NONE,
        &CD3DX12_RESOURCE_DESC::Buffer(elementByteSize_ * elementCount),
        D3D12_RESOURCE_STATE_GENERIC_READ,
        IID_PPV_ARGS(&uploadBuffer_)
    ));
    ThrowIfFailed(uploadBuffer_->Map(0, nullptr, (void **)&mappedData_));
    // if the resource is also modifyed, unmap is not called
    // but the GPU is in use. we don't write data to resource buffer 
}

ID3D12Resource *UploadBuffer::resource() const {
    return uploadBuffer_.Get();
}

void UploadBuffer::copyData(int elementIndex, const T &data) {
    assert(mappedData_ != nullptr && "mappedData_ i")
    memcpy(&mappedData_[elementIndex], &data, sizeof(T));
}

~UploadBuffer::UploadBuffer() {
 	if (uploadBuffer_ != nullptr)
        uploadBuffer_->Unmap(0, nullptr);
}
```

## 常量缓冲区描述符
