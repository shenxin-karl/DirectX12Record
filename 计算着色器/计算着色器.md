# 计算着色器

## 线程与线程组

在GPU编程的过程中，根据程序具体的执行需求，可将线程划分为由线程组构成的网格

每个线程组中都有一块共享内存, 供组内的线程访问. 

* 线程并不能访问其他组中的共享内存
* 同组内的线程间能够进行同步操作

注意:

> 一个线程组中含有[插图]个线程。硬件实际上会将这些线程分为多个warp(每个warp中有32个线程)
>
> 在Direct3D中，我们能够以非32的倍数值来指定线程组的大小。但是出于性能的原因，我们应当总是将线程组的大小设置为warp尺寸的整数倍

**启用线程组**

```cc
void ID3D12GraphicsCommandList::Dispatch(
	UINT ThreadGroupCountX,
    UINT ThreadGroupCountY,
    UINT ThreadGroupCountZ
);
```

**例子: 分派一个 3x2 的线程组**

```cc
pCmdList->Dispatch(3, 2, 1);
```

![Dispatch3x2](Dispatch3x2.png)

***

## 简单的计算着色器

将两个纹理累计的计算着色器示例

```cc
cbuffer cbSettings : register(b0) {
  	// 计算着色器访问的产量缓冲区  
};

Texture2D gInputA : register(t0);
texture2D gInputB : register(t1); 
RWTexture2D<float4> gOuput : register(u0);

// 每个线程组的线程数量, (X, Y, Z) 三个维度的线程数
[numthreads(16, 16, 1)]
void CS(int3 dispatchThreadID : SV_DispatchThreadID) {	// 线程ID
	gOutput[dispatchThreadID.xy] = 
        gInputA[dispatchThreadID.xy] + 
        gInputB[dispatchThreadID.]
}
```

一个计算着色器由下列要素

* 通过常量缓冲区访问的全局变量
* 输入与输出资源
* `[numthreads(X, Y, Z)]` 属性，指定3D线程网格中的线程数量
* 每个线程都要执行的着色器指令
* 线程ID系统值参数

***

### 计算流水线状态对象

为了构建计算着色器的 PSO, 我们需要填写下列结构体

```cc
typedef struct D3D12_COMPUTE_PIPELINE_STATE_DESC {
  ID3D12RootSignature         *pRootSignature;		// 根签名
  D3D12_SHADER_BYTECODE       CS;					// 计算着色器
  UINT                        NodeMask;				// 设备ID
  D3D12_CACHED_PIPELINE_STATE CachedPSO;			
  D3D12_PIPELINE_STATE_FLAGS  Flags;				// 标志位
} D3D12_COMPUTE_PIPELINE_STATE_DESC;
```

使用下面的接口构建 PSO

```cc
HRESULT ID3D12GraphicsCommandList::CreateComputePipelineState(
	const D3D12_COMPUTE_PIPELINE_STATE_DESC *pDesc,
    REFIID                                  riid,
  	void                                    **ppPipelineState
);
```

***

### 数据的输入

前面我们定义了两个**只读的着色器输入**

```cc
Texture2D gInputA : register(t0);
Texture2D gInputB : register(t1);
```

通过给输入纹理 `gInputA` 与 `gInputB` 分别创建 `SRV`, 再将它们作为参数传入根参数, 我们就能令这两个纹理都绑定为着色器的输入资源

```cc
pCmdList->SetComputeRootDescriptorTable(1, srvA);
pCmdList->SetComputeRootDescriptorTable(2, srvB);
```

***

### 纹理输出与无序访问视图

在前一节的计算着色器代码中，我们定义了一个输出资源

**计算着色器处理输出资源的方式比较特殊，它们的类型还有一个特别的前缀“RW”，意为读与写**, 用尖括号模板语法, 指定输出的类型

```cc
RWTexture2D<float4> gOuput : register(u0);
```

为了绑定在计算着色器中要执行写操作的资源，我们需要将其与称为**无序访问视图**

创建 UAV 视图, 需要填写 `D3D12_UNORDERED_ACCESS_VIEW_DESC` 结构体

```cc
void CreateUnorderedAccessView(
 	ID3D12Resource                         *pResource,		
 	ID3D12Resource                         *pCounterResource,
 	const D3D12_UNORDERED_ACCESS_VIEW_DESC *pDesc,
 	D3D12_CPU_DESCRIPTOR_HANDLE            DestDescriptor
);
```

纹理资源创建UAV的示例

```cc
// 创建资源
D3D12_RESOURCE_DESC texDesc;
memset(&texDesc, 0, sizeof(texDesc));
texDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE_2D;
texDesc.Alignment = 0;
texDesc.Width = mWidth;
texDesc.Height = mHeight;
texDesc.DepthOrArraySize = 1;
texDesc.MipLevles = 1;
texDesc.Format = DXGI_FROMAT_R8G8B8A8_UNORM;
texDesc.SamplerDesc.Count = 1;
texDesc.SamplerDesc.Quality = 0;
texDesc.Layout = D3D12_TREXTURE_LAYOUT_UNKNOW;
// 资源必须使用 D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS 创建
texDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;	
ThrowIfFailed(pDevice->CreateCommitedResource(
	RVPtr(CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT)),
    D3D12_HEAP_FLAG_NONE,
    &texDesc,
    D3D12_RESOURCE_STATE_COMMON,
    nullptr,
    IID_PPV_ARGS(&mBlurMap0)
));

// 创建 SRV 视图
D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
srvDesc.Format = mFormat;
srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
srvDesc.Texture2D.MostDetailedMip = 0;
srvDesc.Texture2D.MipLevels = 1;
pDevice->createShaderResourceView(mBlurMap0.Get(), 
	&srvDesc,
	blurOCpuSrv
);

// 创建 UAV 视图
D3D12_UNORDERED_ACCESS_VIEW_DESC uavDesc = {};
uavDesc.Format = mFormat;
uavDesc.ViewDimension = D3D12_UAV_DIMENSION_TEXTURE2D;
uavDesc.Texture2D.MipSlice = 0;
pDevice->createShaderResourceView(mBlurMap0.Get(), 
	&uavDesc,
	blurOCpuUav
);
```

***

### 利用索引对纹理进行采样

纹理元素可以借助2D索引加以访问。计算着色器中，我们基于分派的线程ID来索引纹理; 而每个线程都要被指定一个唯一的调度ID

```cc
[numthread(16, 16, 1)]
void GS(int3 dispatchThreadID : SV_DispatchThreadID) {
    gOutput[dispatchThreadID.xy] = 		
        gInputA[dispatchThreadID.xy] +
        gInputB[dispatchThreadID.xy];
}
```

注意:

> 系统对计算着色器中的索引越界行为有着明确的定义。越界的读操作总是返回0，而向越界处写入数据时却不会实际执行任何操作

由于计算着色器运行在GPU上，因此便可以将它作为访问GPU的一般工具，特别是在通过纹理过滤来对纹理进行采样的时候. 我们不能使用Sample方法，而必须采用 `SampleLevel `方法(第三个参数是 mipmap )

采样纹理时, 需要使用 $[-1, +1]$ 归一化都得坐标, 而不是整数索引
$$
u = \frac{x}{width}\\
v = \frac{y}{height}
$$
采样例子: 使用整数索引采样

```cc
cbuffer cbUpdateSettings : register(b0) {
    float2 gWaveConstant0;
    float2 gWaveConstant1;
    float2 gWaveconstant2;
    float2 gDisturbMag;
    int2   gDisturbIndex;
};

RWTexture2D gPrevSolInput : register(u0);
RWTexture2D gCurrSolInput : register(u1);
RWTexture2D gOutput 	  : register(u2);

// 使用整数索引访问, 不能访问其他 mipmap 
[numthreads(16, 16, 1)]
void CS0(int3 dispatchThreadID : SV_DispatchThreadID) {
    int x = dispatchThreadID.x;
    int y = dispatchThreadID.y;
    gOutput[intx(x, y)] = 
        gWaveConstant0 * gPrevSolInput[int2(x, y)].r +
        gWaveConstant1 * gCurrSolInput[int2(x, y)].r +
        gWaveconstant2 * (
        	gPrevSolInput[int2(x, y+1)].r +
            gPrevSolInput[int2(x, y-1)].r +
        	gPrevSolInput[int2(x+1, y)].r +
        	gPrevSolInput[int2(x-1, y)].r
        );
}

// 使用 SampleLevel 访问, 可以使用过滤方式
void CS0(int3 dispatchThreadID : SV_DispatchThreadID) {
    int x = dispatchThreadID.x;
    int y = dispatchThreadID.y;
    float2 c = float2(x, y) / 512.0;   
    float2 t = float2(x, y-1) / 512.0;
    float2 b = float2(x, y+1) / 512.0;
    float2 l = float2(x-1, y) / 512.0;
    float2 r = float2(x+1, y) / 512.0;
    gOutput[int2(x, y)] = 
		gWaveConstant0 * gPrevSolInput.SampleLevel(samPoint, c, 0.0).r +
        gWaveConstant1 * gCurrSolInput.SampleLevel(samPoint, c, 0.0).r +
		gWaveconstant2 * (
        	gPrevSolInput.SampleLevel(samPoint, b, 0.0).r +
            gPrevSolInput.SampleLevel(samPoint, t, 0.0).r +
        	gPrevSolInput.SampleLevel(samPoint, r, 0.0).r +
        	gPrevSolInput.SampleLevel(samPoint, l, 0.0).r
        );
}
```

***

### 结构化缓冲区资源

结构化缓冲区是一种由相同类型元素所构成的简单缓冲区其本质上是一种数组。正如我们所看到的，该元素类型可以是用户以 `HLSL` 定义的结构体

```cc
struct Data {
    float3 v1;
    float2 v2;
};

StructedBuffer<Data> gInputA  : register(t0);
StructedBuffer<Data> gInputB  : register(t1);
RWStructedBuffer<Data> gOuput : register(u0);
```

**绑定结构化缓冲区**

顶点缓冲区与索引缓冲区创建SRV的方法同样用于创建结构化缓冲区的SRV.

但是必须指定 `D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS`

```cc
struct Data {
    float3 v1;
    float2 v2;
};

// 准备好数据
std::vector<Data> dataA(numDataElements);
std::vector<Data> dataB(numDataElements);
for (std::size_t i = 0; i < numDataElements; ++i) {
    dataA[i].v1 = XMFLOAT3(i, i, i);
    dataA[i].v2 = XMFLOAT2(i, 0);
    dataB[i].v1 = XMFLOAT3(-i, i, 0);
    dataB[i].v2 = XMFLOAT2(0, -i);
}

UINT64 byteSize = numDataElements * sizeof(Data);

// 作为结构化缓冲区输入A, 设置根描述符或者根描述表的方式绑定都着色器上
mInputBufferA = CreateDefaultBuffer(
	pDevice.Get(),
    pCmdList.Get(),
    dataA.data(),
    byteSize,
    mInputUploadBufferA
);
 
// 作为结构化缓冲区输入B. 设置根描述符或者根描述表的方式绑定都着色器上
mInputBufferB = CreateDefaultBuffer(
	pDevice.Get(),
    pCmdList.Get(),
    dataA.data(),
    byteSize,
    mInputUploadBufferB
);

// 创建好资源以后, 创建 UAV, 就可以绑定到流水线中
ThrowIfFailed(pDevice->CreateCommitedResource(
	RVPtr(CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT)),
    D3D12_HEAP_FLAG_NONE,
    RVPtr(CD3DX12_RESOURCE_DESC::Buffer(
        byteSize, 
        D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS	// 使用无序访问标记
    )),
    D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
    nullptr,
    IID_PPV_ARGS(&mOutputBuffer)
));
```

***

### 回读缓冲资源

