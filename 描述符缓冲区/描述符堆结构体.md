## 描述符堆结构体

```cc
/* 
 * @NumDescriptors:	堆中描述符的数量
 * @Type:			D3D12_DESCRIPTOR_HEAP_TYPE 定义的描述符堆类型
 * @Flags:			D3D12_DESCRIPTOR_HEAP_FLAGS 定义的 Flag
 * @NodeMask:		对于单个显示器适配器,设置为0, 否在设置适配器的物理ID
 */
typedef struct D3D12_DESCRIPTOR_HEAP_DESC {
  	UINT                        NumDescriptors;
	D3D12_DESCRIPTOR_HEAP_TYPE  Type;				
  	D3D12_DESCRIPTOR_HEAP_FLAGS Flags;
 	UINT                        NodeMask;
} D3D12_DESCRIPTOR_HEAP_DESC;
```

## 创建渲染目标描述堆

渲染目标描述堆 存储着渲染目标视图. 我们的程序中有 2 个缓冲区, 所有有 2 个渲染目标视图

```cc
constexpr int kSwapChainBufferCount = 2;
ComPtr<ID3D12DescriptorHeap> rtvHeap_;
ComPtr<ID3D12DescriptorHeap> dsvHeap_;

// 创建 rtv 描述符堆
D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc;
rtvHeapDesc.NumDescriptors = kSwapChainBufferCount;
rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
rtvHeapDesc.Flags = D3D12_DESCRIPTOR_FLAG_NONE;
rtvHeapDesc.NodeMask = 0;
ThrowIfFailed(d3dDevice_->CreateDescriptorHeap(
    &rtvHeapDesc,
    IID_PPV_ARGS(&rtvHeap_)
));

// 创建 dsv 描述符堆 
D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc;
rtvHeapDesc.NumDescriptors = kSwapChainBufferCount;
rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
rtvHeapDesc.Flags = D3D12_DESCRIPTOR_FLAG_NONE;
rtvHeapDesc.NodeMask = 0;
ThrowIfFailed(d3dDevice_->CreateDescriptorHeap(
    &dsvHeapDesc,
    IID_PPV_ARGS(&dsvHeap_)
);
```

## 创建渲染目标视图

**使用到的接口**

```cc
/* 
 * @brief:		获得渲染目标的缓冲区
 * @Buffer:		希望获得后台特定缓冲区的索引
 * @riid:		ID3DResource 接口的 COM ID
 * @ppSurface:	返回后台缓冲区
 */
HRESULT IDXGISwapChain::GetBuffer(
    UINT Buffer, REFIID riid, void **ppSurface
);

/*
 * @brief:			创建渲染目标的视图
 * @pResource:		渲染目标的缓冲区
 * @pDesc:			指向D3D12_RENDER_TARGET_VIEW_DESC 的结构体
 * @DescDescriptor:	引用所创建渲染目标视图的描述符句柄
 */
void ID3D12Device::CreateRenderTargetView(
    ID3D12Resource 							*pResource,
    const D3D12_RENDER_TARGET_VIEW_DESCde  	*pDesc,
    D3D12_CPU_DESCRIPTOR_HANDEL 			 DescDescriptor
);
```

## 获取渲染目标描述符堆句柄

```cc
D3D12_CPU_DESCRIPTOR_HANDLE currentBackBufferView() const {
    rreturn CD3DX12_CPU_DESCRIPTOR_HANDLE(
    	rtvHeap_->GetCPUDescriptorHandleForHeapStart(),
        currBackBuffer_,			// 当前的后台缓冲区索引
        rtvDescriptorSize			// 获取的描述符大小
    );
}
```

## 获取深度描述符堆句柄

```cc
D3D12_CPU_DESCRIPTOR_HANDLE depthStencilView() {
    return dsvHeap_->GetCPUDescriptorHandleForHeapStart();
}
```



创建渲染目标视图

```cc
ComPtr<ID3D12Resource> swapChainBuffer_[kSwapChainBufferCount_];
CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHeapHandle;
    = rtvHeap_->GetCPUDescriptorHandleForHeapStart();
for (int i = 0; i < kSwapChainBufferCount_; ++i) {
    // 获取缓冲区
    ThrowIfFailed(swapChain_->GetBuffer(
        i, 
        IID_PPV_ARGS(&swapChainBuffer_[i])
    ));
    
    // 创建一个RTV
    d3dDevice->CreateRenderTargetView(
    	swapChainBuffer_[i].Get(), nullptr, rtvHeapHandle
    );
    
    // 偏移到下一个缓冲区
    rtvHeapHandle.Offset(1, rtvDescriptorSize);
}
```

## 获取渲染目标视图

```cc
ID3D12Resouce *currentRanterTargetView() {
    return swapChainBuffer_[currentBackBuffer_].Get();
}
```

## 资源缓冲区结构体

```cc
/*
 * @Dimension:			纹理的类型. 1D纹理,2D纹理,3D纹理
 * @Alignemnt:			指定对齐
 * @Width:				纹理宽度
 * @Height:				纹理高度
 * @DepthOrArraySize:	以纹素单位来表示纹理的深度, 1D,2D是纹理数组的大小
 * @MipLevels:			mipmap 层级数量
 * @Format:				纹理的格式 RGBA
 * @SampleDesc:			纹理的采样次数
 * @Layout:				指定纹理的布局,暂时不考虑指定为 D3D12_TEXTURE_LAYOUT_UNKNOW
 * @Flags:				杂项标志正常为 D3D12_RESOURCE_FLAG_NONE. 对于深度模板纹理需要指定
 						D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL
 */
typedef struct D3D12_RESOURCE_DESC {
    D3D12_RESOURCE_DIMENSION 	Dimension;
    UINT64						Alignemnt;
    UINT64						Width;
    UINT64						Height;
    UINT16						DepthOrArraySize;
    UINT16						MipLevels;
    DXGI_FORAMT					Format;
    DXGI_SMAPLE_DESC			SampleDesc;
    D3D12_TEXTURE_LAYOUT		Layout;
    D3D12_RESOURCE_MTSC_FLAG	Flags;
} D3D12_RESOURCE_DESC;
```

## 资源清除描述结构体

```cc
/*
 * @Format:			资源的通道格式
 * @Color:			颜色资源使用
 * @DepthStencil	深度模板资源使用
 */
struct D3D12_CLEAR_VALUE {
    DXGI_FORAMT Format;
    union {
        FLOAT 					  Color[4];
        D3D12_DEPTH_STENCIL_VALUE DepthStencil;
    }
}
```

## 创建 GPU 显存块接口

```cc
/*
 * @pHeapProperties:		资源具有的属性, 默认堆;上传堆;回读堆
 * @HeapFlags:				标志位,通常设置为 D3D12_HEAP_FLAG_NONE
 * @pDesc:					D3D_RESOURCE_DESC 资源描述结构体指针
 * @InitialResourceState:	资源初始状态
 * @pOptimizedClearValue:	描述了清除资源的值, 不清除资源可以设置为 nullptr
 * @riidResource:			COM ID
 * @ppvResource:			返回的资源指针
 */
HRESULT ID3D12Device::CreateCommitedResource(
	const D3D12_HEAP_PROPERTIES 	*pHeapProperties,
    D3D12_HEAP_FLAGS 				 HeapFlags,
    const D3D12_RESOURCE_DESC 		*pDesc,
    D3D12_RESOURCE_STATES			 InitialResourceState,
    const D3D12_CLEAR_VALUE 		*pOptimizedClearValue,
    REFIID 							 riidResource,
    void 						   **ppvResource
);
```

## 创建深度模板资源视图

```cc
ComPtr<ID3D12Resource> depthStencilBuffer_;

D3D12_RESOURCE_DESC depthStencilDesc;
depthStencilDesc.Dimension = DED12_RESOURCE_DIMENSION_TEXTURE2D;
depthStencilDesc.Alignment = 0;
depthStencilDesc.Width = clientWidth_;
depthStencilDesc.Height = clientHeight_;
depthStencilDesc.DepthOrArraySize = 1;
depthStencilDesc.MipLevels = 1;
depthStencilDesc.Format = depthStencilFormat_;
depthStencilDesc.SampleDesc.Counnt = msaaState_ ? 4 : 1;
depthStencilDesc.SampleDesc.Quality = msaaState_ ? (msaaQuality-1) : 0;
depthStencilDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOW;
depthStencilDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

D3D12_CLEAR_VALUE optClear;
optClear.Format = depthStencilFormat_;
optClaer.DepthStencil.Depth = 1.0;
optClaer.DepthStencil.Stencil = 0;

// 创建 GPU 显存块
ThrowIfFailed(d3dDevice_->CreateCommitedResource(
	&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
    D3D12_HEAP_FLAG_NONE,
    &depthStencilDesc,
    &optClear,
    IID_PPV_ARGS(&depthStencilBuffer_)
));

// 利用此资源的格式, 为整个资源的第 0 层 Mip 创建描述符
d3dDevice_->CreateDepthStencilView(
	depthStencilBuffer_.Get(),
    nullptr,
    depthStencilView()
);

// 将资源从初始状态转换为深度缓冲区
commandList_->ResourceBarrier(
	1,
    &CD3DX12_RESOURCE_BARRIER::Transition(
    	depthStencilBuffer_.Get(),
        D3D12_RESOURCE_STATE_COMMON,
        DED12_RESOURCE_STATE_DEPTH_WRITE
    )
);
```

## 获取深度模板视图

```cc
ID3D12Resource *currentDepthStencilView() {
    return depthStencilBuffer_.Get();
}
```

## 顶点索引默认缓冲区工具函数



## 索引缓冲区

1. 使用 `createDefaultBuffer` 创建显存块
2. 使用 `D3D12_INDEX_BUFFER_VIEW` 创建视图. 
3. 写入索引数据同时绑定索引数据到流水线

### 索引视图结构体

```cc
typedef struct D3D12_INDEX_BUFFER_VIEW {
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;
 	UINT                      SizeInBytes;
  	DXGI_FORMAT               Format;
} D3D12_INDEX_BUFFER_VIEW;
```

**创建例子**

```cc
ComPtr<ID3D12Resource> indexBufferGPU;
ComPtr<ID3D12Resource> indexBufferUploader;
// 创建默认显存块
indexBufferGPU = createDefaultBuffer(
	commandList_.Get(), indices, sizeof(indices), indexBufferUploader
);

// 填写视图结构体
D3D12_INDEX_BUFFER_VIEW ibv;
ibv.BufferLocation = indexBufferGPU->GetGPUVirtualAddress();
ibv.Format = DXGI_FORMAT_R16_UINT;
ibv.SizeInByte = sizeof(indices);

// 绑定到流水线
commandList_->IASetIndexBuffer(&ibv);
```

## 常量缓冲区

常量缓冲区是用 `D3D12_HEAP_TYPE_UPLOAD` 堆类型创建的. **常量缓冲区里面的数据是 256 对齐的**

1. 创建 `D3D12_HEAP_TYPE_UPLOAD` 显存块
2. 使用 `Map` 函数获取数据映射的地址
3. 使用 `memcpy` 将数据拷贝到 `Map` 获得地址
4. 不使用以后, 使用 `Unmap` 释放映射的地址

### 上传缓冲区辅助类

```cc
template<typename T>
class UploadBuffer {
    UploadBuffer(ID3D12Device *device, UINT elememtCount, bool isConstantBuffer);
    UploadBuffer(const UploadBuffer &) = delete;
    UploadBuffer &operator=(const UploadBuffer &) = delete;
	ID3D12Resource *resource() const;
    void copyData(int elementIndex, const T &data);
    ~UploadBuffer();
private:
    ComPtr<ID3D12Resource>   uploadBuffer_;
    BYTE 					*mappedData = nullptr;
    UINT 					*elementByteSize_ = 0;
    bool 					 isConstantBuffer_ = false;
};

template<typename T>
UploadBuffer::UploadBuffer(ID3D12Device *device, UINT elememtCount,
                           bool isConstantBuffer)
: elementByteSize_(elementCount), isConstantBuffer_(isConstantBuffer) {
    if (isConstantBuffer)
        elementByteSize_ = (sizeof(T) + 0xff) & ~0xff;	// 256对齐
    ThrowIfFailed(device->CreateCommitedResource(
    	&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
        D3D12_HEAP_FLAG_NONE,
        &CD3D12_RESOURCE_DESC::Buffer(elementByteSize_ * elememtCount),
        D3D12_RESOURCE_STATE_GENERIC_READ,
        nullptr,
        IID_PPV_ARGS(&uploadBuffer_)
    ));
    
    ThrowIfFailed(uploadBuffer_->Map(0, nullptr, (void *)&mappedData));
}

template<typename T>
ID3D12Resource *UploadBuffer<T>::resource() const {
    return uploadBuffer_.Get();
}

template<typename T>
UploadBuffer<T>::~UploadBuffer() {
    if (uploadBuffer_ != nullptr)
        uploadBuffer_->Unmap(0, nullptr);
}

template<typename T>
void copyData(int index, const T &data) {
    memcpy(&mappedData_[index], &data, sizeof(T));
}
```

## 常量缓冲区描述堆

利用描述符将常量缓冲区绑定到渲染流水线上. 常量缓冲区描述符需要存放在

`D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SR_UAV` 类型所创建的描述符堆. 这种堆内可以混合存放 **常量缓冲区描述符, 着色器资源描述符, 无序访问描述符**

**创建 `D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SR_UAV` 描述符堆**

```cc
D3D12_DESCRIPTOR_HEAP_DESC cbvHeapDesc;
cbvHeapDesc.NumDescriptors = 1;
cbvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SR_UAV;
cbvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE; // 只使用 CBV
cbvHeapDesc.NodeMask = 0;

ComPtr<ID3D12DescriptorHeap> cubHeap_;
d3dDevice_->CreateDescriptorHeap(&cbvHeapDesc, IID_PPV_ARGS(&cbvHeap_));
```

## 常量缓冲区视图结构体

```cc
struct D3D12_CONSTANT_BUFFER_VIEW_DESC {
 	  D3D12_GPU_VIRTUAL_ADDRESS BufferLocation;	// 虚拟GPU地址
  	UINT                      	SizeInBytes;   	// 字节s
} D3D12_CONSTANT_BUFFER_VIEW_DESC;
```

## 绑定常量缓冲区到流水线

```cc
struct ObjectConstants {
    XMFLOAT4X4 worldViewPorj;
};

unique_ptr<UploadBuffer<ObjectConstants>> objectCB = nullptr;
objectCB = make_unique<UploadBuffer<ObjectConstants>>(
	d3dDevice_.Get(), n, true
);

// 256 对齐
size_t objCBByteSize = (sizeof(ObjectConstants) + 0xff) & ~0xff;
auto cbAddress = objectCB->resource()->GetGPUVirtualAddress();
int boxCBufIndex = i;	// 偏移到第 i 个物体所需要的常量数据
cbAddress += boxCBufIndex * objCBByteSize;

// 视图结构体
D3D12_CONSTANT_BUFFER_VIEW_DESC cbvDesc;
cbvDesc.BufferLocation = cbAddress;
cbvDesc.SizeInBytes = (sizeof(ObjectConstants) + 0xff) & ~0xff;

// bind
d3dDevice_->CreateConstantBufferView(
    &cbvDesc, 
	cbvHeap_->GetCPUDescriptorHandleForStart()
);
```

